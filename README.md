# README

## Архитектура проекта

Проект построен на основе FSM , что обеспечивает четкое разделение логики по состояниям и облегчает расширение, отладку и поддержку кода.
Для инъекции зависимостей использован Zenject.
Для трудоемких задач, используются Jobs.

Структура расположения скриптов:
 * Common — модуль с сервисами, не зависящими от конкретного проекта.
 * Gameplay — скрипты, напрямую связанные с игровым процессом.
 * GameStateMachine — скрипты, относящиеся к машине состояний и всем состояниям.
 * UI — скрипты пользовательских интерфейсов.

Основные модули проекта:

* Bootstrap — стартовая сцена, отвечающая за первичную инициализацию и запуск машины состояний.
* GameStateMachine — ядро приложения, управляющее переходами между состояниями.
* UIManager — отвечает за отображение и обновление пользовательского интерфейса.

## Последовательность работы

1. Bootstrap сцена

   * Инициализируются все зависимости через Zenject.
   * Создается и запускается машина состояний.

2. InitializeState 

   * Инициализируются различные сервисы (в данный момент — UIManager).
   * В будущем может быть расширен инициализацией рекламы, аналитики и других подсистем.
   * После завершения подготовки выполняется переход в состояние меню.

3. MenuState

   * Базовое состояние игры.
   * Из меню можно перейти к выбору уровня.
   * В дальнейшем можно расширить фичами, настройками и т.д.
   
4. LevelSelectState

   * Через ILevelService получаем список доступных уровней.
   * Вызывается UI для показа, и туда передаются выбираемые варианты
   * При выборе уровня, стартует LevelInitializeState (если нужна вариация геймплея, можно из выбранного уровня вычленять нужный тип и запускать конкретно нужный тому уровню LevelInitializeState). 

4. LevelInitializeState

   * Загружается сцена уровня.
   * Создаются и инициализируются юниты через сервис IUnitSpawn, модификаторы берутся из IUnitsModifications.
   * Подготавливается интерфейс для расстановки юнитов.
   * Осуществляется выбор пользователем нужной формации (дополнительная игровая функция).

5. GameplayState

   * Происходит инициализация IUnitsController, который управляет всеми юнитами:
     * Инициализация сервиса ответственного за поиск путей ITargetSearcher.
     * Инициализация сервиса ответственного за перемещение юнитов IUnitMover.
     * Инициализация сервиса ответственного за боевку юнитов IUnitAttacker.
   * После завершения боя определяется результат, показывается UI, с которого можно выйти обратно в меню.

6. LevelReleaseState

   * Перед переходом в меню, вызывается данный стейт, который выгружает использованные ресурсы
   * Возвращается в меню.

## Логика модификаций:
  * Есть общая структура - Modification, которая хранит в себе тип изменяемого параметра, способ его изменения и значение изменения
  * Все модификаторы (SizeModification, ColorModification) - есть структуры, которые хранят в себе массив Modification и параметр (размер, цвет)
  * Базовый префаб визуала для Unit содержит в себе модификации присущие его форме и monoBeh наследуемый от IUnitContainer (который в случае, если будет реализовывать ISizeModifiable, IColorModifiable будет также визуально воспринимать эти модификаторы.
  * Все модификаторы и базовые параметры юнитов хранятся в IUnitsModifications.
    
## Дополнительная функция
Я выбрал функцию как изменение строя, но если выбирать, что-то посложнее, то это очень связано с целевой игрой. Если бы мы делали некий Crowd Runner, то я бы добавил пробежку по воротам перед финальной битвой. Если мы делаем именно упор на симуляцию сражений, то добавил бы функции для контроля юнитов, возможно какие бонусные эффекты вроде удара извне.
