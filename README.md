# README

## Архитектура проекта

Проект построен на основе FSM , что обеспечивает четкое разделение логики по состояниям и облегчает расширение, отладку и поддержку кода.
Для инъекции зависимостей использован Zenject.
Для трудоемких задач, используются job.

Структура расположения скриптов:
 * Common - отдельный модуль с независящими от конкретного проекта сервисами
 * Gameplay - скрипты, напрямую связанные с процессом игры
 * GameStateMachine - скрипты, относящиеся к машине состояний и все состояния к ней
 * UI - скрипты всех UI-ных окон 

Основные модули проекта:

* Bootstrap — стартовая сцена, отвечающая за первичную инициализацию и запуск машины состояний.
* GameStateMachine — ядро приложения, управляющее переходами между состояниями.
* UIManager — отвечает за отображение и обновление пользовательского интерфейса.

## Последовательность работы

1. Bootstrap сцена

   * Инициализируются все зависимости через Zenject.
   * Создается и запускается машина состояний.

2. InitializeState 

   * Инициализируются различные сервисы, в данный момент UIManager, при расширении могут добавится инит рекламы, аналитик и т.д.
   * После завершения подготовки выполняется переход в состояние меню.

3. MenuState

   * Базовое состояние игры
   * Отсюда можно перейти к выборы уровней, также расширяемо настройками, фичами и тд. и тп. 

4. LevelSelectState

   * Через ILevelService получаем список доступных уровней.
   * Вызывается UI для показа, и туда передаются выбираемые варианты
   * При выборе уровня, стартует LevelInitializeState (если нужна вариация геймплея, можно из выбранного уровня вычленять нужный тип и запускать конкретно нужный тому уровню LevelInitializeState). 

4. LevelInitializeState

   * Загружается сцена уровня.
   * Создаются и инициализируются юниты через сервис IUnitSpawn, модификаторы берутся из IUnitsModifications.
   * Подготавливается интерфейс расстановки юнитов.
   * Осуществляется выбор пользователем нужной формации (что выбрано как дополнительной функцией).

5. GameplayState

   * Происходит инициализация IUnitsController, который управляет всеми юнитами:
     * Инициализация сервиса ответственного за поиск путей ITargetSearcher.
     * Инициализация сервиса ответственного за перемещение юнитов IUnitMover.
     * Инициализация сервиса ответственного за боевку юнитов IUnitAttacker.
   * После завершения боя определяется результат, показывается UI, с которого можно выйти обратно в меню.

6. LevelReleaseState

   * Перед переходом в меню, вызывается данный стейт, который выгружает использованные ресурсы
   * Возвращается в меню.

## Логика модификаций:
  * Есть общая структура - Modification, которая хранит в себе тип изменяемого параметра, способ его изменения и значение изменения
  * Все модификаторы (SizeModification, ColorModification) - есть структуры, которые хранят в себе массив Modification и параметр (размер, цвет)
  * Базовый префаб визуала для Unit содержит в себе модификации присущие его форме и monoBeh наследуемый от IUnitContainer (который в случае, если будет реализовывать ISizeModifiable, IColorModifiable будет также визуально воспринимать эти модификаторы.
  * Все модификаторы и базовые параметры юнитов хранятся в IUnitsModifications.  
